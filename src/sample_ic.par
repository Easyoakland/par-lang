type Bool  = either { .true!, .false! }
type Option<T>  = either { .some T, .none! }
dec true: Bool
def true = .true!
dec false: Bool
def false = .false!

dec not: [Bool] Bool
def not = [x] x {
	true? => .false!
	false? => .true!
}


type Tree = recursive either {
  .empty!
  .item(self)(self)!
}

dec empty: Tree
def empty = .empty!

dec tree: Tree
def tree =
    let b: Tree = .item(empty)(empty)! in
    .item(empty)(b)!


dec xor: [Bool][Bool] Bool
def xor = [a][b] a{
	true? => not(b)
	false? => b
}

dec xor_tree: [Tree] Bool

def xor_tree = [tree: Tree] tree begin {
	empty? => .true!
	item[lst1][lst2]? => xor(lst1 loop)(lst2 loop)
}


dec is_some: [Option<Bool>] Bool
def is_some = [option: Option<Bool>] option {
    some val => val
    none? => .false!
}

dec main: Tree
def main = .empty!

dec quant: (type T) (T) (T) [T] [T] Bool
def quant = (type Bool) (.true!) (.false!) [x] [y] x {
    true? => y {
        true? => .false!
        false? => .true!
    }
    false? => y {
        true? => .false!
        false? => .true!
    }

}
