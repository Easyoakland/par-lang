type Bool = either { .true! .false! }

type List<T> = recursive either {
  .empty!
  .item(T) self
}

dec alternate:
  [List<Bool>] [List<Bool>]
  recursive either {
    .remainder either {
      .left List<Bool>
      .right List<Bool>
    }
    .choice {
      left => (Bool) self
      right => (Bool) self
    }
  }

def alternate = [la] [lb]
    la begin @a {
        empty? => .remainder .right lb
        item[ha] la => lb begin @b {
            empty? => .remainder .left .item (ha) la
            item [hb] lb => .choice {
                left => (ha) let lb = .item (hb) lb in la loop@a
                right => (hb) lb loop@b
            }
        }
    }
dec left_list  : List<Bool>
dec right_list : List<Bool>

def left_list  = .item(.false!).item(.true!).empty!
def right_list = .item(.true!).empty!

def alternate_applied = alternate(left_list)(right_list)
